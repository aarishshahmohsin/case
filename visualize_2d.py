import matplotlib
matplotlib.use("Agg")  # Non-GUI backend for WSL or headless environments

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from src.datasets.synthetic_datasets import BinaryClusterDataset
from src.constants import epsilon_N, epsilon_P

import matplotlib.colors as mcolors

def value_to_color(value, color0, color1):
    """
    Linearly interpolate between color0 and color1 for value between 0 and 1.
    """
    c0 = np.array(mcolors.to_rgb(color0))
    c1 = np.array(mcolors.to_rgb(color1))
    return (c0 + c1) /2 

# -------------------------
# Load dataset and FP logs
# -------------------------
# Load the CSV file generated by the feasibility pump logging
df = pd.read_csv('./feaspump_variables.csv')

# Generate toy dataset
# dataset = BinaryClusterDataset()
# P, N = dataset.generate()
P = np.load('./P_Binary.npy')
N = np.load('./N_Binary.npy')

# -------------------------
# Helper function
# -------------------------
def safe_get(df_row, variable_name, default=0):
    """
    Safely get a variable value from a dataframe row.
    Handles missing variables gracefully.
    """
    if variable_name in df_row.columns:
        val = df_row[variable_name].iloc[0] if len(df_row) > 0 else default
        return float(val)
    return float(default)

# -------------------------
# Animation function
# -------------------------
def animate_feaspump(df, P_points, N_points, epsilon_P=epsilon_P, epsilon_N=epsilon_N, interval=500, show_labels=True):
    """
    Animate dataset and hyperplane evolution with margins epsilon_P and epsilon_N.
    Updated to work with the new CSV format: Stage,Iteration,var1,var2,...
    """
    iterations = df['Iteration'].unique()
    
    # Build frames: (iteration, stage)
    frames = []
    for iteration in sorted(iterations):
        stages_in_iter = df[df['Iteration'] == iteration]['Stage'].unique()
        if 'LP' in stages_in_iter:
            frames.append((iteration, 'LP'))
        if 'ROUNDED' in stages_in_iter:
            frames.append((iteration, 'ROUNDED'))

    fig, ax = plt.subplots(figsize=(8, 6))
    P_scatter = ax.scatter(P_points[:, 0], P_points[:, 1], c='red', label='P Points', s=50)
    N_scatter = ax.scatter(N_points[:, 0], N_points[:, 1], c='blue', label='N Points', s=50)
    hyperplane_line, = ax.plot([], [], 'k-', linewidth=2, label='Hyperplane')
    positive_margin_line, = ax.plot([], [], 'g--', linewidth=1.5, label='+ Margin')
    negative_margin_line, = ax.plot([], [], 'r--', linewidth=1.5, label='- Margin')
    ax.legend()
    ax.grid(True, alpha=0.3)

    def get_row(iteration, stage):
        """Get the dataframe row for specific iteration and stage"""
        return df[(df['Iteration'] == iteration) & (df['Stage'] == stage)]

    # Last known hyperplane parameters
    last_w0, last_w1, last_c = 0.0, 1.0, 0.0

    def update(frame_idx):
        nonlocal last_w0, last_w1, last_c
        iteration, stage = frames[frame_idx]
        row_data = get_row(iteration, stage)
        
        if len(row_data) == 0:
            return P_scatter, N_scatter, hyperplane_line, positive_margin_line, negative_margin_line

        # Update hyperplane parameters (assuming variable names like w0, w1, c or similar)
        # Adjust these variable names based on your actual SCIP variable names
        if stage == 'LP':
            # Update hyperplane parameters from LP solution
            last_w0 = safe_get(row_data, 't_w_0', last_w0)  # Replace 'w0' with your actual weight variable name
            last_w1 = safe_get(row_data, 't_w_1', last_w1)  # Replace 'w1' with your actual weight variable name  
            last_c = safe_get(row_data, 't_c', last_c)     # Replace 'c' with your actual constant variable name

        w0, w1, c = last_w0, last_w1, last_c

        # Generate hyperplane line data
        x_min = min(P_points[:, 0].min(), N_points[:, 0].min()) - 1
        x_max = max(P_points[:, 0].max(), N_points[:, 0].max()) + 1
        x_vals = np.linspace(x_min, x_max, 100)

        if abs(w1) > 1e-8:
            # Main hyperplane: w0*x + w1*y + c = 0 => y = -(w0*x + c)/w1
            # Calculate norm of weight vector
            w_norm = np.sqrt(w0**2 + w1**2)

            # Decision boundary: w0*x + w1*y + c = 0
            y_main = -(w0 * x_vals + c) / w1

            # Margin offset in actual geometric space
            epsilon_P_new = epsilon_P 
            epsilon_N_new = epsilon_N 

            # Unit normal vector (pointing perpendicular to boundary)
            normal_vec = np.array([w0, w1]) / w_norm

            # Vertical component of normal vector
            normal_y = normal_vec[1]

            # Shift the main boundary up and down by margin offset
            y_pos = y_main + epsilon_P_new * normal_y
            y_neg = y_main - epsilon_N_new * normal_y


            hyperplane_line.set_data(x_vals, y_main)
            positive_margin_line.set_data(x_vals, y_pos)
            negative_margin_line.set_data(x_vals, y_neg)
        else:
            # Vertical line case or degenerate case
            hyperplane_line.set_data([], [])
            positive_margin_line.set_data([], [])
            negative_margin_line.set_data([], [])

        # Color points based on variable values (assuming variables like x_0, x_1, ..., y_0, y_1, ...)
        if show_labels:
            P_colors = []
            for i in range(len(P_points)):
                # Adjust variable name format based on your SCIP model
                var_name = f't_x_{i}'  # or 'x[{i}]' or whatever format your variables use
                val = safe_get(row_data, var_name, 0)
                
                if val == 0:   # Essentially 0
                    P_colors.append('brown')
                elif val == 1: # Essentially 1
                    P_colors.append('red')
                else:              # Fractional
                    rgb = value_to_color(val, 'brown', 'red')
                    P_colors.append(rgb)
            
            N_colors = []
            for j in range(len(N_points)):
                # Adjust variable name format based on your SCIP model
                var_name = f't_y_{j}'  # or 'y[{j}]' or whatever format your variables use
                val = safe_get(row_data, var_name, 0)
                
                if val == 0:
                    N_colors.append('blue')
                elif val == 1:
                    N_colors.append('orange')
                else:
                    rgb = value_to_color(val, 'blue', 'orange')
                    N_colors.append(rgb)
            
            P_scatter.set_color(P_colors)
            N_scatter.set_color(N_colors)

        # Set axis limits to keep view stable
        ax.set_xlim(x_min, x_max)
        y_min = min(P_points[:, 1].min(), N_points[:, 1].min()) - 1
        y_max = max(P_points[:, 1].max(), N_points[:, 1].max()) + 1
        ax.set_ylim(y_min, y_max)
        
        ax.set_title(f"Feasibility Pump - Iteration {iteration} ({stage})")
        ax.set_xlabel("Feature 1")
        ax.set_ylabel("Feature 2")
        
        return P_scatter, N_scatter, hyperplane_line, positive_margin_line, negative_margin_line

    anim = FuncAnimation(fig, update, frames=len(frames), interval=interval, blit=False, repeat=True)
    return anim

# -------------------------
# Enhanced animation for detailed CSV format
# -------------------------
def animate_feaspump_detailed(df, P_points, N_points, epsilon_P=epsilon_P, epsilon_N=epsilon_N, interval=500, show_labels=True):
    """
    Animation function for the detailed CSV format with fractionality information.
    Assumes CSV format: Stage,Iteration,var1_value,var1_frac,var2_value,var2_frac,...
    """
    iterations = df['Iteration'].unique()
    
    frames = []
    for iteration in sorted(iterations):
        stages_in_iter = df[df['Iteration'] == iteration]['Stage'].unique()
        if 'LP' in stages_in_iter:
            frames.append((iteration, 'LP'))
        if 'ROUNDED' in stages_in_iter:
            frames.append((iteration, 'ROUNDED'))

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))
    
    # Left plot: Main visualization
    P_scatter = ax1.scatter(P_points[:, 0], P_points[:, 1], c='red', label='P Points', s=50)
    N_scatter = ax1.scatter(N_points[:, 0], N_points[:, 1], c='blue', label='N Points', s=50)
    hyperplane_line, = ax1.plot([], [], 'k-', linewidth=2, label='Hyperplane')
    positive_margin_line, = ax1.plot([], [], 'g--', linewidth=1.5, label='+ Margin')
    negative_margin_line, = ax1.plot([], [], 'r--', linewidth=1.5, label='- Margin')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    ax1.set_title("Hyperplane Evolution")
    
    # Right plot: Fractionality over time
    ax2.set_title("Variable Fractionality")
    ax2.set_xlabel("Variables")
    ax2.set_ylabel("Fractionality")
    ax2.set_ylim(0, 0.6)

    def get_row(iteration, stage):
        return df[(df['Iteration'] == iteration) & (df['Stage'] == stage)]

    last_w0, last_w1, last_c = 0.0, 1.0, 0.0

    def update(frame_idx):
        nonlocal last_w0, last_w1, last_c
        iteration, stage = frames[frame_idx]
        row_data = get_row(iteration, stage)
        
        if len(row_data) == 0:
            return P_scatter, N_scatter, hyperplane_line, positive_margin_line, negative_margin_line

        # Update hyperplane (adjust variable names as needed)
        if stage == 'LP':
            last_w0 = safe_get(row_data, 't_w_0', last_w0)
            last_w1 = safe_get(row_data, 't_w_1', last_w1)  
            last_c = safe_get(row_data, 't_c', last_c)

        # Update main plot (same as before)
        w0, w1, c = last_w0, last_w1, last_c
        x_min = min(P_points[:, 0].min(), N_points[:, 0].min()) - 1
        x_max = max(P_points[:, 0].max(), N_points[:, 0].max()) + 1
        x_vals = np.linspace(x_min, x_max, 100)

        if abs(w1) > 1e-8:
            y_main = -(w0 * x_vals + c) / w1
            y_pos = -(w0 * x_vals + c - epsilon_P) / w1
            y_neg = -(w0 * x_vals + c + epsilon_N) / w1
            hyperplane_line.set_data(x_vals, y_main)
            positive_margin_line.set_data(x_vals, y_pos)
            negative_margin_line.set_data(x_vals, y_neg)

        # Update fractionality plot
        ax2.clear()
        if stage == 'LP':
            # Extract fractionality values
            frac_vars = [col for col in row_data.columns if col.endswith('_frac')]
            if frac_vars:
                frac_values = [safe_get(row_data, var, 0) for var in frac_vars]
                var_names = [var.replace('_frac', '') for var in frac_vars]
                
                colors = ['red' if 't_x_' in name else 'blue' if 't_y_' in name else 'green' for name in var_names]
                bars = ax2.bar(range(len(frac_values)), frac_values, color=colors, alpha=0.7)
                ax2.set_xticks(range(len(var_names)))
                ax2.set_xticklabels(var_names, rotation=45, ha='right')
                ax2.set_ylabel("Fractionality")
                ax2.set_title(f"Variable Fractionality - Iteration {iteration}")
                ax2.set_ylim(0, 0.6)

        ax1.set_xlim(x_min, x_max)
        y_min = min(P_points[:, 1].min(), N_points[:, 1].min()) - 1
        y_max = max(P_points[:, 1].max(), N_points[:, 1].max()) + 1
        ax1.set_ylim(y_min, y_max)
        ax1.set_title(f"Iteration {iteration} ({stage})")
        
        return P_scatter, N_scatter, hyperplane_line, positive_margin_line, negative_margin_line

    anim = FuncAnimation(fig, update, frames=len(frames), interval=interval, blit=False, repeat=True)
    return anim

# -------------------------
# Generate and save animation
# -------------------------
print("Loading data and generating animation...")

# Choose which animation to use based on your CSV format:
# For basic format (Stage,Iteration,var1,var2,...)
try:
    anim = animate_feaspump(df, P, N, interval=1000)
    print("Using basic animation format")
except Exception as e:
    print(f"Basic format failed: {e}")
    try:
        # For detailed format (Stage,Iteration,var1_value,var1_frac,var2_value,var2_frac,...)
        anim = animate_feaspump_detailed(df, P, N, interval=1000)
        print("Using detailed animation format")
    except Exception as e:
        print(f"Detailed format also failed: {e}")
        exit(1)

print("Saving animation files...")
anim.save("feaspump_animation.gif", writer="pillow", fps=12)
print("GIF saved as feaspump_animation.gif")

try:
    anim.save("feaspump_animation.mp4", writer="ffmpeg", fps=12)
    print("MP4 saved as feaspump_animation.mp4")
except Exception as e:
    print(f"MP4 save failed (ffmpeg may not be installed): {e}")

# Display final statistics
print(f"\nAnimation contains {len(df)} data points across {len(df['Iteration'].unique())} iterations")
print(f"Variables in dataset: {[col for col in df.columns if col not in ['Stage', 'Iteration']]}")

# Optional: open GIF in Windows from WSL
# import os
# os.system("explorer.exe feaspump_animation.gif")